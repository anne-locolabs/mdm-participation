{"version":3,"file":"js/9762-ed16aef261f82965059d.chunk.js","mappings":"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","sources":["webpack://decidim-development-app/./node_modules/graphql-ws/dist/common-CGW11Fyb.js","webpack://decidim-development-app/./node_modules/graphql-ws/dist/client.js","webpack://decidim-development-app/./node_modules/graphql/utilities/getOperationAST.mjs","webpack://decidim-development-app/./node_modules/graphql/jsutils/isAsyncIterable.mjs","webpack://decidim-development-app/./node_modules/graphql/jsutils/toError.mjs","webpack://decidim-development-app/./node_modules/graphql/error/locatedError.mjs","webpack://decidim-development-app/./node_modules/graphql/jsutils/isPromise.mjs","webpack://decidim-development-app/./node_modules/graphql/jsutils/memoize3.mjs","webpack://decidim-development-app/./node_modules/graphql/jsutils/promiseForObject.mjs","webpack://decidim-development-app/./node_modules/graphql/jsutils/promiseReduce.mjs","webpack://decidim-development-app/./node_modules/graphql/execution/execute.mjs","webpack://decidim-development-app/./node_modules/graphql/execution/mapAsyncIterator.mjs","webpack://decidim-development-app/./node_modules/graphql/execution/subscribe.mjs","webpack://decidim-development-app/./node_modules/graphql/version.mjs","webpack://decidim-development-app/./node_modules/graphql-ws/dist/server-3ewaJSjp.js"],"sourcesContent":["function extendedTypeof(val) {\n  if (val === null) {\n    return \"null\";\n  }\n  if (Array.isArray(val)) {\n    return \"array\";\n  }\n  return typeof val;\n}\nfunction isObject(val) {\n  return extendedTypeof(val) === \"object\";\n}\nfunction isAsyncIterable(val) {\n  return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\nfunction isAsyncGenerator(val) {\n  return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === \"function\" && typeof val.return === \"function\";\n}\nfunction areGraphQLFormattedErrors(obj) {\n  return Array.isArray(obj) && // must be at least one error\n  obj.length > 0 && // error has at least a message\n  obj.every((ob) => \"message\" in ob);\n}\nfunction limitCloseReason(reason, whenTooLong) {\n  return reason.length < 124 ? reason : whenTooLong;\n}\n\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = \"graphql-transport-ws\";\nconst DEPRECATED_GRAPHQL_WS_PROTOCOL = \"graphql-ws\";\nvar CloseCode = /* @__PURE__ */ ((CloseCode2) => {\n  CloseCode2[CloseCode2[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n  CloseCode2[CloseCode2[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n  CloseCode2[CloseCode2[\"BadRequest\"] = 4400] = \"BadRequest\";\n  CloseCode2[CloseCode2[\"BadResponse\"] = 4004] = \"BadResponse\";\n  CloseCode2[CloseCode2[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n  CloseCode2[CloseCode2[\"Forbidden\"] = 4403] = \"Forbidden\";\n  CloseCode2[CloseCode2[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n  CloseCode2[CloseCode2[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n  CloseCode2[CloseCode2[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n  CloseCode2[CloseCode2[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n  CloseCode2[CloseCode2[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  return CloseCode2;\n})(CloseCode || {});\nvar MessageType = /* @__PURE__ */ ((MessageType2) => {\n  MessageType2[\"ConnectionInit\"] = \"connection_init\";\n  MessageType2[\"ConnectionAck\"] = \"connection_ack\";\n  MessageType2[\"Ping\"] = \"ping\";\n  MessageType2[\"Pong\"] = \"pong\";\n  MessageType2[\"Subscribe\"] = \"subscribe\";\n  MessageType2[\"Next\"] = \"next\";\n  MessageType2[\"Error\"] = \"error\";\n  MessageType2[\"Complete\"] = \"complete\";\n  return MessageType2;\n})(MessageType || {});\nfunction validateMessage(val) {\n  if (!isObject(val)) {\n    throw new Error(\n      `Message is expected to be an object, but got ${extendedTypeof(val)}`\n    );\n  }\n  if (!val.type) {\n    throw new Error(`Message is missing the 'type' property`);\n  }\n  if (typeof val.type !== \"string\") {\n    throw new Error(\n      `Message is expects the 'type' property to be a string, but got ${extendedTypeof(\n        val.type\n      )}`\n    );\n  }\n  switch (val.type) {\n    case \"connection_init\" /* ConnectionInit */:\n    case \"connection_ack\" /* ConnectionAck */:\n    case \"ping\" /* Ping */:\n    case \"pong\" /* Pong */: {\n      if (val.payload != null && !isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`\n        );\n      }\n      break;\n    }\n    case \"subscribe\" /* Subscribe */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(\n            val.payload\n          )}`\n        );\n      }\n      if (typeof val.payload.query !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'query' property to be a string, but got ${extendedTypeof(\n            val.payload.query\n          )}`\n        );\n      }\n      if (val.payload.variables != null && !isObject(val.payload.variables)) {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(\n            val.payload.variables\n          )}`\n        );\n      }\n      if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(\n            val.payload.operationName\n          )}`\n        );\n      }\n      if (val.payload.extensions != null && !isObject(val.payload.extensions)) {\n        throw new Error(\n          `\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(\n            val.payload.extensions\n          )}`\n        );\n      }\n      break;\n    }\n    case \"next\" /* Next */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!isObject(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an object, but got ${extendedTypeof(\n            val.payload\n          )}`\n        );\n      }\n      break;\n    }\n    case \"error\" /* Error */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      if (!areGraphQLFormattedErrors(val.payload)) {\n        throw new Error(\n          `\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(\n            val.payload\n          )}`\n        );\n      }\n      break;\n    }\n    case \"complete\" /* Complete */: {\n      if (typeof val.id !== \"string\") {\n        throw new Error(\n          `\"${val.type}\" message expects the 'id' property to be a string, but got ${extendedTypeof(\n            val.id\n          )}`\n        );\n      }\n      if (!val.id) {\n        throw new Error(\n          `\"${val.type}\" message requires a non-empty 'id' property`\n        );\n      }\n      break;\n    }\n    default:\n      throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n  }\n  return val;\n}\nfunction parseMessage(data, reviver) {\n  return validateMessage(\n    typeof data === \"string\" ? JSON.parse(data, reviver) : data\n  );\n}\nfunction stringifyMessage(msg, replacer) {\n  validateMessage(msg);\n  return JSON.stringify(msg, replacer);\n}\n\nexport { CloseCode as C, DEPRECATED_GRAPHQL_WS_PROTOCOL as D, GRAPHQL_TRANSPORT_WS_PROTOCOL as G, MessageType as M, isAsyncGenerator as a, isAsyncIterable as b, isObject as i, limitCloseReason as l, parseMessage as p, stringifyMessage as s, validateMessage as v };\n","import { i as isObject, G as GRAPHQL_TRANSPORT_WS_PROTOCOL, s as stringifyMessage, M as MessageType, C as CloseCode, l as limitCloseReason, p as parseMessage } from './common-CGW11Fyb.js';\nexport { D as DEPRECATED_GRAPHQL_WS_PROTOCOL, v as validateMessage } from './common-CGW11Fyb.js';\n\nfunction createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries2) {\n      const retryDelaySeconds = Math.pow(2, retries2);\n      await new Promise(\n        (resolve) => setTimeout(\n          resolve,\n          retryDelaySeconds * 1e3 + // add random timeout from 300ms to 3s\n          Math.floor(Math.random() * (3e3 - 300) + 300)\n        )\n      );\n    },\n    shouldRetry = isLikeCloseEvent,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error(\"Invalid WebSocket implementation provided\");\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== \"undefined\") {\n    ws = WebSocket;\n  } else if (typeof global !== \"undefined\") {\n    ws = global.WebSocket || // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== \"undefined\") {\n    ws = window.WebSocket || // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws)\n    throw new Error(\n      \"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\"\n    );\n  const WebSocketImpl = ws;\n  const emitter = (() => {\n    const message = /* @__PURE__ */ (() => {\n      const listeners2 = {};\n      return {\n        on(id, listener) {\n          listeners2[id] = listener;\n          return () => {\n            delete listeners2[id];\n          };\n        },\n        emit(message2) {\n          if (\"id\" in message2) listeners2[message2.id]?.(message2);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: on?.connecting ? [on.connecting] : [],\n      opened: on?.opened ? [on.opened] : [],\n      connected: on?.connected ? [on.connected] : [],\n      ping: on?.ping ? [on.ping] : [],\n      pong: on?.pong ? [on.pong] : [],\n      message: on?.message ? [message.emit, on.message] : [message.emit],\n      closed: on?.closed ? [on.closed] : [],\n      error: on?.error ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        for (const listener of [...listeners[event]]) {\n          listener(...args);\n        }\n      }\n    };\n  })();\n  function errorOrClosed(cb) {\n    const listening = [\n      // errors are fatal and more critical than close events, throw them first\n      emitter.on(\"error\", (err) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(err);\n      }),\n      // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on(\"closed\", (event) => {\n        listening.forEach((unlisten) => unlisten());\n        cb(event);\n      })\n    ];\n  }\n  let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n  async function connect() {\n    clearTimeout(lazyCloseTimeout);\n    const [socket, throwOnClose] = await (connecting ?? (connecting = new Promise(\n      (connected, denied) => (async () => {\n        if (retrying) {\n          await retryWait(retries);\n          if (!locks) {\n            connecting = void 0;\n            return denied({ code: 1e3, reason: \"All Subscriptions Gone\" });\n          }\n          retries++;\n        }\n        emitter.emit(\"connecting\", retrying);\n        const socket2 = new WebSocketImpl(\n          typeof url === \"function\" ? await url() : url,\n          GRAPHQL_TRANSPORT_WS_PROTOCOL\n        );\n        let connectionAckTimeout, queuedPing;\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing);\n            queuedPing = setTimeout(() => {\n              if (socket2.readyState === WebSocketImpl.OPEN) {\n                socket2.send(stringifyMessage({ type: MessageType.Ping }));\n                emitter.emit(\"ping\", false, void 0);\n              }\n            }, keepAlive);\n          }\n        }\n        errorOrClosed((errOrEvent) => {\n          connecting = void 0;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n          if (errOrEvent instanceof TerminatedCloseEvent) {\n            socket2.close(4499, \"Terminated\");\n            socket2.onerror = null;\n            socket2.onclose = null;\n          }\n        });\n        socket2.onerror = (err) => emitter.emit(\"error\", err);\n        socket2.onclose = (event) => emitter.emit(\"closed\", event);\n        socket2.onopen = async () => {\n          try {\n            emitter.emit(\"opened\", socket2);\n            const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n            if (socket2.readyState !== WebSocketImpl.OPEN) return;\n            socket2.send(\n              stringifyMessage(\n                payload ? {\n                  type: MessageType.ConnectionInit,\n                  payload\n                } : {\n                  type: MessageType.ConnectionInit\n                  // payload is completely absent if not provided\n                },\n                replacer\n              )\n            );\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket2.close(\n                  CloseCode.ConnectionAcknowledgementTimeout,\n                  \"Connection acknowledgement timeout\"\n                );\n              }, connectionAckWaitTimeout);\n            }\n            enqueuePing();\n          } catch (err) {\n            emitter.emit(\"error\", err);\n            socket2.close(\n              CloseCode.InternalClientError,\n              limitCloseReason(\n                err instanceof Error ? err.message : String(err),\n                \"Internal client error\"\n              )\n            );\n          }\n        };\n        let acknowledged = false;\n        socket2.onmessage = ({ data }) => {\n          try {\n            const message = parseMessage(data, reviver);\n            emitter.emit(\"message\", message);\n            if (message.type === \"ping\" || message.type === \"pong\") {\n              emitter.emit(message.type, true, message.payload);\n              if (message.type === \"pong\") {\n                enqueuePing();\n              } else if (!disablePong) {\n                socket2.send(\n                  stringifyMessage(\n                    message.payload ? {\n                      type: MessageType.Pong,\n                      payload: message.payload\n                    } : {\n                      type: MessageType.Pong\n                      // payload is completely absent if not provided\n                    }\n                  )\n                );\n                emitter.emit(\"pong\", false, message.payload);\n              }\n              return;\n            }\n            if (acknowledged) return;\n            if (message.type !== MessageType.ConnectionAck)\n              throw new Error(\n                `First message cannot be of type ${message.type}`\n              );\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit(\"connected\", socket2, message.payload, retrying);\n            retrying = false;\n            retries = 0;\n            connected([\n              socket2,\n              new Promise((_, reject) => errorOrClosed(reject))\n            ]);\n          } catch (err) {\n            socket2.onmessage = null;\n            emitter.emit(\"error\", err);\n            socket2.close(\n              CloseCode.BadResponse,\n              limitCloseReason(\n                err instanceof Error ? err.message : String(err),\n                \"Bad response\"\n              )\n            );\n          }\n        };\n      })()\n    )));\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n    let release = () => {\n    };\n    const released = new Promise((resolve) => release = resolve);\n    return [\n      socket,\n      release,\n      Promise.race([\n        // wait for\n        released.then(() => {\n          if (!locks) {\n            const complete = () => socket.close(1e3, \"Normal Closure\");\n            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n              lazyCloseTimeout = setTimeout(() => {\n                if (socket.readyState === WebSocketImpl.OPEN) complete();\n              }, lazyCloseTimeoutMs);\n            } else {\n              complete();\n            }\n          }\n        }),\n        // or\n        throwOnClose\n      ])\n    ];\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n      CloseCode.InternalServerError,\n      CloseCode.InternalClientError,\n      CloseCode.BadRequest,\n      CloseCode.BadResponse,\n      CloseCode.Unauthorized,\n      // CloseCode.Forbidden, might grant access out after retry\n      CloseCode.SubprotocolNotAcceptable,\n      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      CloseCode.SubscriberAlreadyExists,\n      CloseCode.TooManyInitialisationRequests\n      // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code)))\n      throw errOrCloseEvent;\n    if (disposed) return false;\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)\n      return locks > 0;\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    return retrying = true;\n  }\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [, , throwOnClose] = await connect();\n          await throwOnClose;\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent2) {\n            return onNonLazyError?.(errOrCloseEvent2);\n          }\n        }\n      }\n    })();\n  }\n  function subscribe(payload, sink) {\n    const id = generateID(payload);\n    let done = false, errored = false, releaser = () => {\n      locks--;\n      done = true;\n    };\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n          if (done) return release();\n          const unlisten = emitter.onMessage(id, (message) => {\n            switch (message.type) {\n              case MessageType.Next: {\n                sink.next(message.payload);\n                return;\n              }\n              case MessageType.Error: {\n                errored = true, done = true;\n                sink.error(message.payload);\n                releaser();\n                return;\n              }\n              case MessageType.Complete: {\n                done = true;\n                releaser();\n                return;\n              }\n            }\n          });\n          socket.send(\n            stringifyMessage(\n              {\n                id,\n                type: MessageType.Subscribe,\n                payload\n              },\n              replacer\n            )\n          );\n          releaser = () => {\n            if (!done && socket.readyState === WebSocketImpl.OPEN)\n              socket.send(\n                stringifyMessage(\n                  {\n                    id,\n                    type: MessageType.Complete\n                  },\n                  replacer\n                )\n              );\n            locks--;\n            done = true;\n            release();\n          };\n          await waitForReleaseOrThrowOnClose.finally(unlisten);\n          return;\n        } catch (errOrCloseEvent) {\n          if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n        }\n      }\n    })().then(() => {\n      if (!errored) sink.complete();\n    }).catch((err) => {\n      sink.error(err);\n    });\n    return () => {\n      if (!done) releaser();\n    };\n  }\n  return {\n    on: emitter.on,\n    subscribe,\n    iterate(request) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {\n        }\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      });\n      const iterator = async function* iterator2() {\n        for (; ; ) {\n          if (!pending.length) {\n            await new Promise((resolve) => deferred.resolve = resolve);\n          }\n          while (pending.length) {\n            yield pending.shift();\n          }\n          if (deferred.error) {\n            throw deferred.error;\n          }\n          if (deferred.done) {\n            return;\n          }\n        }\n      }();\n      iterator.throw = async (err) => {\n        if (!deferred.done) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        }\n        return { done: true, value: void 0 };\n      };\n      iterator.return = async () => {\n        dispose();\n        return { done: true, value: void 0 };\n      };\n      return iterator;\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        const [socket] = await connecting;\n        socket.close(1e3, \"Normal Closure\");\n      }\n    },\n    terminate() {\n      if (connecting) {\n        emitter.emit(\"closed\", new TerminatedCloseEvent());\n      }\n    }\n  };\n}\nclass TerminatedCloseEvent extends Error {\n  name = \"TerminatedCloseEvent\";\n  message = \"4499: Terminated\";\n  code = 4499;\n  reason = \"Terminated\";\n  wasClean = false;\n}\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([\n    1e3,\n    // Normal Closure is not an erroneous close code\n    1001,\n    // Going Away\n    1006,\n    // Abnormal Closure\n    1005,\n    // No Status Received\n    1012,\n    // Service Restart\n    1013,\n    // Try Again Later\n    1014\n    // Bad Gateway\n  ].includes(code))\n    return false;\n  return code >= 1e3 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\n\nexport { CloseCode, GRAPHQL_TRANSPORT_WS_PROTOCOL, MessageType, TerminatedCloseEvent, createClient, parseMessage, stringifyMessage };\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  let operation = null;\n\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (\n        ((_definition$name = definition.name) === null ||\n        _definition$name === void 0\n          ? void 0\n          : _definition$name.value) === operationName\n      ) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n","/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n  return (\n    typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0\n      ? void 0\n      : maybeAsyncIterable[Symbol.asyncIterator]) === 'function'\n  );\n}\n","import { inspect } from './inspect.mjs';\n/**\n * Sometimes a non-error is thrown, wrap it as an Error instance to ensure a consistent Error interface.\n */\n\nexport function toError(thrownValue) {\n  return thrownValue instanceof Error\n    ? thrownValue\n    : new NonErrorThrown(thrownValue);\n}\n\nclass NonErrorThrown extends Error {\n  constructor(thrownValue) {\n    super('Unexpected error value: ' + inspect(thrownValue));\n    this.name = 'NonErrorThrown';\n    this.thrownValue = thrownValue;\n  }\n}\n","import { toError } from '../jsutils/toError.mjs';\nimport { GraphQLError } from './GraphQLError.mjs';\n/**\n * Given an arbitrary value, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\n\nexport function locatedError(rawOriginalError, nodes, path) {\n  var _nodes;\n\n  const originalError = toError(rawOriginalError); // Note: this uses a brand-check to support GraphQL errors originating from other contexts.\n\n  if (isLocatedGraphQLError(originalError)) {\n    return originalError;\n  }\n\n  return new GraphQLError(originalError.message, {\n    nodes:\n      (_nodes = originalError.nodes) !== null && _nodes !== void 0\n        ? _nodes\n        : nodes,\n    source: originalError.source,\n    positions: originalError.positions,\n    path,\n    originalError,\n  });\n}\n\nfunction isLocatedGraphQLError(error) {\n  return Array.isArray(error.path);\n}\n","/**\n * Returns true if the value acts like a Promise, i.e. has a \"then\" function,\n * otherwise returns false.\n */\nexport function isPromise(value) {\n  return (\n    typeof (value === null || value === void 0 ? void 0 : value.then) ===\n    'function'\n  );\n}\n","/**\n * Memoizes the provided three-argument function.\n */\nexport function memoize3(fn) {\n  let cache0;\n  return function memoized(a1, a2, a3) {\n    if (cache0 === undefined) {\n      cache0 = new WeakMap();\n    }\n\n    let cache1 = cache0.get(a1);\n\n    if (cache1 === undefined) {\n      cache1 = new WeakMap();\n      cache0.set(a1, cache1);\n    }\n\n    let cache2 = cache1.get(a2);\n\n    if (cache2 === undefined) {\n      cache2 = new WeakMap();\n      cache1.set(a2, cache2);\n    }\n\n    let fnResult = cache2.get(a3);\n\n    if (fnResult === undefined) {\n      fnResult = fn(a1, a2, a3);\n      cache2.set(a3, fnResult);\n    }\n\n    return fnResult;\n  };\n}\n","/**\n * This function transforms a JS object `ObjMap<Promise<T>>` into\n * a `Promise<ObjMap<T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport function promiseForObject(object) {\n  return Promise.all(Object.values(object)).then((resolvedValues) => {\n    const resolvedObject = Object.create(null);\n\n    for (const [i, key] of Object.keys(object).entries()) {\n      resolvedObject[key] = resolvedValues[i];\n    }\n\n    return resolvedObject;\n  });\n}\n","import { isPromise } from './isPromise.mjs';\n\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\nexport function promiseReduce(values, callbackFn, initialValue) {\n  let accumulator = initialValue;\n\n  for (const value of values) {\n    accumulator = isPromise(accumulator)\n      ? accumulator.then((resolved) => callbackFn(resolved, value))\n      : callbackFn(accumulator, value);\n  }\n\n  return accumulator;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe, _options$maxCoercionE;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n    options,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors:\n        (_options$maxCoercionE =\n          options === null || options === void 0\n            ? void 0\n            : options.maxCoercionErrors) !== null &&\n        _options$maxCoercionE !== void 0\n          ? _options$maxCoercionE\n          : 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  try {\n    for (const [responseName, fieldNodes] of fields.entries()) {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result !== undefined) {\n        results[responseName] = result;\n\n        if (isPromise(result)) {\n          containsPromise = true;\n        }\n      }\n    }\n  } catch (error) {\n    if (containsPromise) {\n      // Ensure that any promises returned by other fields are handled, as they may also reject.\n      return promiseForObject(results).finally(() => {\n        throw error;\n      });\n    }\n\n    throw error;\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n","/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const resultOrStream = await createSourceEventStream(args);\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({ ...args, rootValue: payload }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg && 'document' in firstArg) {\n    return firstArg;\n  }\n\n  return {\n    schema: firstArg,\n    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    subscribeFieldResolver: args[6],\n  };\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(...rawArgs) {\n  const args = toNormalizedArgs(rawArgs);\n  const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n","// Note: This file is autogenerated using \"resources/gen-version.js\" script and\n// automatically updated by \"npm version\" command.\n\n/**\n * A string containing the version of the GraphQL.js library\n */\nexport const version = '16.11.0';\n/**\n * An object containing the components of the GraphQL.js version string\n */\n\nexport const versionInfo = Object.freeze({\n  major: 16,\n  minor: 11,\n  patch: 0,\n  preReleaseTag: null,\n});\n","import { parse, validate, getOperationAST, GraphQLError, subscribe, execute, versionInfo } from 'graphql';\nimport { G as GRAPHQL_TRANSPORT_WS_PROTOCOL, C as CloseCode, p as parseMessage, M as MessageType, a as isAsyncGenerator, b as isAsyncIterable, s as stringifyMessage, i as isObject } from './common-CGW11Fyb.js';\n\nfunction makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate: validate$1,\n    execute: execute$1,\n    subscribe: subscribe$1,\n    connectionInitWaitTimeout = 3e3,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(\n          CloseCode.SubprotocolNotAcceptable,\n          \"Subprotocol not acceptable\"\n        );\n        return async (code, reason) => {\n          await onClose?.(ctx, code, reason);\n        };\n      }\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived)\n          socket.close(\n            CloseCode.ConnectionInitialisationTimeout,\n            \"Connection initialisation timeout\"\n          );\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage(async function onMessage(data) {\n        let message;\n        try {\n          message = parseMessage(data, reviver);\n        } catch (err) {\n          return socket.close(CloseCode.BadRequest, \"Invalid message received\");\n        }\n        switch (message.type) {\n          case MessageType.ConnectionInit: {\n            if (ctx.connectionInitReceived)\n              return socket.close(\n                CloseCode.TooManyInitialisationRequests,\n                \"Too many initialisation requests\"\n              );\n            ctx.connectionInitReceived = true;\n            if (isObject(message.payload))\n              ctx.connectionParams = message.payload;\n            const permittedOrPayload = await onConnect?.(ctx);\n            if (permittedOrPayload === false)\n              return socket.close(CloseCode.Forbidden, \"Forbidden\");\n            ctx.acknowledged = true;\n            await socket.send(\n              stringifyMessage(\n                isObject(permittedOrPayload) ? {\n                  type: MessageType.ConnectionAck,\n                  payload: permittedOrPayload\n                } : {\n                  type: MessageType.ConnectionAck\n                  // payload is completely absent if not provided\n                },\n                replacer\n              )\n            );\n            return;\n          }\n          case MessageType.Ping: {\n            if (socket.onPing)\n              return await socket.onPing(message.payload);\n            await socket.send(\n              stringifyMessage(\n                message.payload ? { type: MessageType.Pong, payload: message.payload } : {\n                  type: MessageType.Pong\n                  // payload is completely absent if not provided\n                }\n              )\n            );\n            return;\n          }\n          case MessageType.Pong:\n            return await socket.onPong?.(message.payload);\n          case MessageType.Subscribe: {\n            if (!ctx.acknowledged)\n              return socket.close(CloseCode.Unauthorized, \"Unauthorized\");\n            const { id, payload } = message;\n            if (id in ctx.subscriptions)\n              return socket.close(\n                CloseCode.SubscriberAlreadyExists,\n                `Subscriber for ${id} already exists`\n              );\n            ctx.subscriptions[id] = null;\n            const emit = {\n              next: async (result, { id: id2, payload: payload2 }, args) => {\n                const { errors, ...resultWithoutErrors } = result;\n                const maybeResult = await onNext?.(\n                  ctx,\n                  id2,\n                  payload2,\n                  args,\n                  result\n                );\n                await socket.send(\n                  stringifyMessage(\n                    {\n                      id: id2,\n                      type: MessageType.Next,\n                      payload: maybeResult || {\n                        ...resultWithoutErrors,\n                        // omit errors completely if not defined\n                        ...errors ? { errors: errors.map((e) => e.toJSON()) } : {}\n                      }\n                    },\n                    replacer\n                  )\n                );\n              },\n              error: async (errors, { id: id2, payload: payload2 }) => {\n                const maybeErrors = await onError?.(ctx, id2, payload2, errors);\n                await socket.send(\n                  stringifyMessage(\n                    {\n                      id: id2,\n                      type: MessageType.Error,\n                      payload: maybeErrors || errors.map((e) => e.toJSON())\n                    },\n                    replacer\n                  )\n                );\n              },\n              complete: async (notifyClient, { id: id2, payload: payload2 }) => {\n                await onComplete?.(ctx, id2, payload2);\n                if (notifyClient)\n                  await socket.send(\n                    stringifyMessage(\n                      {\n                        id: id2,\n                        type: MessageType.Complete\n                      },\n                      replacer\n                    )\n                  );\n              }\n            };\n            try {\n              let execArgs;\n              const maybeExecArgsOrErrors = await onSubscribe?.(\n                ctx,\n                message.id,\n                message.payload\n              );\n              if (maybeExecArgsOrErrors) {\n                if (areGraphQLErrors(maybeExecArgsOrErrors))\n                  return id in ctx.subscriptions ? await emit.error(maybeExecArgsOrErrors, message) : void 0;\n                else if (Array.isArray(maybeExecArgsOrErrors))\n                  throw new Error(\n                    \"Invalid return value from onSubscribe hook, expected an array of GraphQLError objects\"\n                  );\n                execArgs = maybeExecArgsOrErrors;\n              } else {\n                if (!schema)\n                  throw new Error(\"The GraphQL schema is not provided\");\n                const args = {\n                  operationName: payload.operationName,\n                  document: parse(payload.query),\n                  variableValues: payload.variables\n                };\n                execArgs = {\n                  ...args,\n                  schema: typeof schema === \"function\" ? await schema(ctx, id, payload, args) : schema\n                };\n                const validationErrors = (validate$1 ?? validate)(\n                  execArgs.schema,\n                  execArgs.document\n                );\n                if (validationErrors.length > 0)\n                  return id in ctx.subscriptions ? await emit.error(validationErrors, message) : void 0;\n              }\n              const operationAST = getOperationAST(\n                execArgs.document,\n                execArgs.operationName\n              );\n              if (!operationAST)\n                return id in ctx.subscriptions ? await emit.error(\n                  [new GraphQLError(\"Unable to identify operation\")],\n                  message\n                ) : void 0;\n              if (!(\"rootValue\" in execArgs))\n                execArgs.rootValue = roots?.[operationAST.operation];\n              if (!(\"contextValue\" in execArgs))\n                execArgs.contextValue = typeof context === \"function\" ? await context(ctx, id, payload, execArgs) : context;\n              let operationResult;\n              if (operationAST.operation === \"subscription\")\n                operationResult = await (subscribe$1 ?? subscribe)(\n                  execArgs\n                );\n              else\n                operationResult = await (execute$1 ?? execute)(execArgs);\n              const maybeResult = await onOperation?.(\n                ctx,\n                id,\n                payload,\n                execArgs,\n                operationResult\n              );\n              if (maybeResult) operationResult = maybeResult;\n              if (isAsyncIterable(operationResult)) {\n                if (!(id in ctx.subscriptions)) {\n                  if (isAsyncGenerator(operationResult))\n                    operationResult.return(void 0);\n                } else {\n                  ctx.subscriptions[id] = operationResult;\n                  try {\n                    for await (const result of operationResult) {\n                      await emit.next(result, message, execArgs);\n                    }\n                  } catch (err) {\n                    const originalError = err instanceof Error ? err : new Error(String(err));\n                    await emit.error(\n                      [\n                        versionInfo.major >= 16 ? new GraphQLError(\n                          originalError.message,\n                          // @ts-ignore graphql@15 and less dont have the second arg as object (version is ensured by versionInfo.major check above)\n                          { originalError }\n                        ) : (\n                          // versionInfo.major <= 15\n                          new GraphQLError(\n                            originalError.message,\n                            null,\n                            null,\n                            null,\n                            null,\n                            originalError\n                          )\n                        )\n                      ],\n                      message\n                    );\n                  }\n                }\n              } else {\n                if (id in ctx.subscriptions)\n                  await emit.next(operationResult, message, execArgs);\n              }\n              await emit.complete(id in ctx.subscriptions, message);\n            } finally {\n              delete ctx.subscriptions[id];\n            }\n            return;\n          }\n          case MessageType.Complete: {\n            const subscription = ctx.subscriptions[message.id];\n            delete ctx.subscriptions[message.id];\n            if (isAsyncGenerator(subscription))\n              await subscription.return(void 0);\n            return;\n          }\n          default:\n            throw new Error(\n              `Unexpected message of type ${message.type} received`\n            );\n        }\n      });\n      return async (code, reason) => {\n        if (connectionInitWait) clearTimeout(connectionInitWait);\n        const subs = { ...ctx.subscriptions };\n        ctx.subscriptions = {};\n        await Promise.all(\n          Object.values(subs).filter(isAsyncGenerator).map((sub) => sub.return(void 0))\n        );\n        if (ctx.acknowledged) await onDisconnect?.(ctx, code, reason);\n        await onClose?.(ctx, code, reason);\n      };\n    }\n  };\n}\nfunction handleProtocols(protocols) {\n  switch (true) {\n    case (protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL)):\n    case (Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL)):\n    case (typeof protocols === \"string\" && protocols.split(\",\").map((p) => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL)):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}\nfunction areGraphQLErrors(obj) {\n  return Array.isArray(obj) && // must be at least one error\n  obj.length > 0 && // error has at least a message\n  obj.every((ob) => ob instanceof GraphQLError);\n}\n\nexport { areGraphQLErrors as a, handleProtocols as h, makeServer as m };\n"],"names":["extendedTypeof","val","isObject","isAsyncIterable","isAsyncGenerator","areGraphQLFormattedErrors","obj","ob","limitCloseReason","reason","whenTooLong","GRAPHQL_TRANSPORT_WS_PROTOCOL","DEPRECATED_GRAPHQL_WS_PROTOCOL","CloseCode","CloseCode2","MessageType","MessageType2","validateMessage","parseMessage","data","reviver","stringifyMessage","msg","replacer","createClient","options","url","connectionParams","lazy","onNonLazyError","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","retries2","retryDelaySeconds","resolve","shouldRetry","isLikeCloseEvent","on","webSocketImpl","generateID","c","r","ws","isWebSocket","WebSocketImpl","emitter","message","listeners2","id","listener","message2","_a","listeners","event","l","args","errorOrClosed","cb","listening","err","unlisten","connecting","locks","lazyCloseTimeout","retrying","retries","disposed","connect","socket","throwOnClose","connected","denied","socket2","connectionAckTimeout","queuedPing","enqueuePing","errOrEvent","TerminatedCloseEvent","payload","acknowledged","_","reject","release","released","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","errOrCloseEvent2","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","request","pending","deferred","dispose","iterator","code","getOperationAST","documentAST","operationName","operation","definition","_definition$name","maybeAsyncIterable","toError","thrownValue","NonErrorThrown","inspect","locatedError","rawOriginalError","nodes","path","_nodes","originalError","isLocatedGraphQLError","GraphQLError","error","value","memoize3","fn","cache0","a1","a2","a3","cache1","cache2","fnResult","promiseForObject","object","resolvedValues","resolvedObject","i","key","promiseReduce","values","callbackFn","initialValue","accumulator","resolved","collectSubfields","exeContext","returnType","fieldNodes","execute","devAssert","schema","document","variableValues","rootValue","assertValidExecutionArguments","buildExecutionContext","result","executeOperation","buildResponse","executeSync","errors","rawVariableValues","isObjectLike","_operation$variableDe","_options$maxCoercionE","contextValue","fieldResolver","typeResolver","subscribeFieldResolver","fragments","variableDefinitions","coercedVariableValues","defaultFieldResolver","defaultTypeResolver","rootType","rootFields","collectFields","executeFields","executeFieldsSerially","parentType","sourceValue","fields","results","responseName","fieldPath","executeField","resolvedResult","containsPromise","source","_fieldDef$resolve","fieldDef","getFieldDef","resolveFn","info","buildResolveInfo","completed","completeValue","rawError","handleFieldError","completeListValue","completeLeafValue","completeAbstractValue","completeObjectValue","invariant","isIterableObject","itemType","completedResults","item","index","itemPath","completedItem","serializedResult","_returnType$resolveTy","resolveTypeFn","runtimeType","resolvedRuntimeType","ensureValidRuntimeType","runtimeTypeName","subFieldNodes","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","abstractType","possibleTypes","promisedIsTypeOfResults","type","isTypeOfResult","isTypeOfResults","property","fieldNode","fieldName","mapAsyncIterator","iterable","callback","mapResult","_e","resultOrStream","createSourceEventStream","toNormalizedArgs","firstArg","rawArgs","eventStream","executeSubscription","_fieldDef$subscribe","version","versionInfo","makeServer","context","roots","validate$1","execute$1","subscribe$1","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","extra","ctx","connectionInitWait","permittedOrPayload","emit","id2","payload2","resultWithoutErrors","maybeResult","e","maybeErrors","notifyClient","execArgs","maybeExecArgsOrErrors","areGraphQLErrors","validationErrors","validate","operationAST","operationResult","subscription","subs","sub","handleProtocols","protocols","p"],"sourceRoot":""}